package golang

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/printer"
	"go/token"
	"os"

	"github.com/arnavdugar/hsm/codegen/config"
	"github.com/arnavdugar/hsm/codegen/parser"
)

type Renderer parser.Machine

func Create(machine *parser.Machine) *Renderer {
	return (*Renderer)(machine)
}

func (renderer *Renderer) Render() ([]byte, error) {
	var buffer bytes.Buffer

	buffer.WriteString(`// Autogenerated. Do not modify.
//
// This file can be regenerated by running
// go run github.com/arnavdugar/hsm/codegen`)
	for _, value := range os.Args[1:] {
		buffer.WriteString(" ")
		buffer.WriteString(value)
	}
	buffer.WriteString("\n\n")

	config := printer.Config{
		Mode:     printer.TabIndent | printer.UseSpaces,
		Tabwidth: 8,
	}
	err := config.Fprint(&buffer, token.NewFileSet(), &ast.File{
		Name: &ast.Ident{
			Name: renderer.Codegen.Golang.Package,
		},
		Decls: renderer.createDeclarations(),
	})
	if err != nil {
		return nil, err
	}

	return buffer.Bytes(), nil
}

func (renderer *Renderer) createDeclarations() []ast.Decl {
	declarations := []ast.Decl{
		createImports(renderer.Codegen.Golang.Imports),
	}

	if renderer.Codegen.Golang.DeclareActions {
		declarations = append(
			declarations,
			createEnumDeclaration(renderer.Actions.Type, "int"),
			createActionTypeEnumDeclaration(renderer.Actions))
	}

	if renderer.Codegen.Golang.DeclareStates {
		declarations = append(
			declarations,
			createEnumDeclaration(renderer.States.Type, "int"),
			createStateTypeEnumDeclaration(renderer.States))
	}

	declarations = append(
		declarations,
		renderer.createHandlerInterface(),
		renderer.createHandleFunction(),
	)

	for _, action := range renderer.Actions.Values {
		declarations = append(
			declarations,
			renderer.createHandleActionMethod(action))
	}

	return declarations
}

func createImports(imports []config.Import) *ast.GenDecl {
	spec := []ast.Spec{
		&ast.ImportSpec{
			Path: &ast.BasicLit{
				Kind:  token.STRING,
				Value: `"github.com/arnavdugar/hsm/runtime"`,
			},
		},
	}

	for _, value := range imports {
		spec = append(spec, createImport(value))
	}

	return &ast.GenDecl{
		Tok:   token.IMPORT,
		Specs: spec,
	}
}

func createImport(importEntry config.Import) *ast.ImportSpec {
	var importName *ast.Ident
	if importEntry.Name != "" {
		importName = &ast.Ident{
			Name: importEntry.Name,
		}
	}

	return &ast.ImportSpec{
		Name: importName,
		Path: &ast.BasicLit{
			Kind:  token.STRING,
			Value: fmt.Sprintf(`"%s"`, importEntry.Path),
		},
	}
}

func createEnumDeclaration(symbol string, enumType string) *ast.GenDecl {
	return &ast.GenDecl{
		Tok: token.TYPE,
		Specs: []ast.Spec{
			&ast.TypeSpec{
				Name: &ast.Ident{
					Name: symbol,
				},
				Type: &ast.Ident{
					Name: enumType,
				},
			},
		},
	}
}

func createActionTypeEnumDeclaration(actions config.Actions) *ast.GenDecl {
	specs := []ast.Spec{}

	for index, action := range actions.Values {
		specs = append(specs, &ast.ValueSpec{
			Names: []*ast.Ident{{
				Name: action.Symbol,
			}},
			Type: &ast.Ident{
				Name: actions.Type,
			},
			Values: []ast.Expr{
				&ast.BasicLit{
					Kind:  token.INT,
					Value: fmt.Sprintf("%d", index+1),
				},
			},
		})
	}

	return &ast.GenDecl{
		Tok:   token.CONST,
		Specs: specs,
	}
}

func createStateTypeEnumDeclaration(states config.States) *ast.GenDecl {
	specs := []ast.Spec{}

	for index, state := range states.Values {
		specs = append(specs, &ast.ValueSpec{
			Names: []*ast.Ident{{
				Name: state.Symbol,
			}},
			Type: &ast.Ident{
				Name: states.Type,
			},
			Values: []ast.Expr{
				&ast.BasicLit{
					Kind:  token.INT,
					Value: fmt.Sprintf("%d", index+1),
				},
			},
		})
	}

	return &ast.GenDecl{
		Tok:   token.CONST,
		Specs: specs,
	}
}

func (renderer *Renderer) createHandlerInterface() *ast.GenDecl {
	methods := []*ast.Field{}

	paramsList := []*ast.Field{}
	if renderer.Codegen.Golang.Context != "" {
		paramsList = append(paramsList, &ast.Field{
			Names: []*ast.Ident{{
				Name: "ctx",
			}},
			Type: &ast.Ident{
				Name: renderer.Codegen.Golang.Context,
			},
		})
	}

	for _, action := range renderer.Actions.Values {
		actionData := renderer.ActionsMap[action.Name]

		actionParamsList := paramsList
		if actionData.Action.DataType != "" {
			actionParamsList = append(actionParamsList, &ast.Field{
				Names: []*ast.Ident{{
					Name: "data",
				}},
				Type: &ast.Ident{
					Name: actionData.Action.DataType,
				},
			})
		}

		for _, guard := range actionData.Guards.Values() {
			methods = append(methods, createGuardMethodSignature(guard, paramsList))
		}

		for _, transition := range actionData.Transitions.Values() {
			methods = append(
				methods, createBoundaryMethodSignature(transition, actionParamsList))
		}
	}

	for _, state := range renderer.States.Values {
		if state.Enter != "" {
			methods = append(methods,
				createBoundaryMethodSignature(state.Enter, paramsList))
		}
		if state.Exit != "" {
			methods = append(methods,
				createBoundaryMethodSignature(state.Exit, paramsList))
		}
	}

	return &ast.GenDecl{
		Tok: token.TYPE,
		Specs: []ast.Spec{
			&ast.TypeSpec{
				Name: &ast.Ident{
					Name: "Handler",
				},
				Type: &ast.InterfaceType{
					Methods: &ast.FieldList{
						List: methods,
					},
				},
			},
		},
	}
}

func createBoundaryMethodSignature(
	name string, paramsList []*ast.Field,
) *ast.Field {
	return &ast.Field{
		Names: []*ast.Ident{{
			Name: name,
		}},
		Type: &ast.FuncType{
			Params: &ast.FieldList{
				List: paramsList,
			},
			Results: &ast.FieldList{
				List: []*ast.Field{{
					Type: &ast.Ident{
						Name: "error",
					},
				}},
			},
		},
	}
}

func createGuardMethodSignature(
	name string, paramsList []*ast.Field,
) *ast.Field {
	return &ast.Field{
		Names: []*ast.Ident{{
			Name: name,
		}},
		Type: &ast.FuncType{
			Params: &ast.FieldList{
				List: paramsList,
			},
			Results: &ast.FieldList{
				List: []*ast.Field{{
					Type: &ast.Ident{
						Name: "bool",
					},
				}, {
					Type: &ast.Ident{
						Name: "error",
					},
				}},
			},
		},
	}
}

func (renderer *Renderer) createHandleFunction() *ast.FuncDecl {
	return &ast.FuncDecl{
		Doc: &ast.CommentGroup{
			List: []*ast.Comment{{
				Text: "\n// Handles an action and returns the destination state or an error.\n",
			}},
		},
		Name: &ast.Ident{
			Name: "Handle",
		},
		Type: &ast.FuncType{
			Params: &ast.FieldList{
				List: renderer.createHandleParams(),
			},
			Results: &ast.FieldList{
				List: []*ast.Field{{
					Type: &ast.Ident{
						Name: renderer.States.Type,
					},
				}, {
					Type: &ast.Ident{
						Name: "error",
					},
				}},
			},
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.SwitchStmt{
					Tag: &ast.Ident{
						Name: "action",
					},
					Body: &ast.BlockStmt{
						List: renderer.createHandleActionCases(),
					},
				},
			},
		},
	}
}

func (renderer *Renderer) createHandleParams() []*ast.Field {
	params := []*ast.Field{}

	if renderer.Codegen.Golang.Context != "" {
		params = append(params, &ast.Field{
			Names: []*ast.Ident{{
				Name: "ctx",
			}},
			Type: &ast.Ident{
				Name: renderer.Codegen.Golang.Context,
			},
		})
	}

	params = append(params, &ast.Field{
		Names: []*ast.Ident{{
			Name: "handler",
		}},
		Type: &ast.Ident{
			Name: "Handler",
		},
	}, &ast.Field{
		Names: []*ast.Ident{{
			Name: "state",
		}},
		Type: &ast.Ident{
			Name: renderer.States.Type,
		},
	}, &ast.Field{
		Names: []*ast.Ident{{
			Name: "action",
		}},
		Type: &ast.Ident{
			Name: renderer.Actions.Type,
		},
	}, &ast.Field{
		Names: []*ast.Ident{{
			Name: "data",
		}},
		Type: &ast.Ident{
			Name: "interface{}",
		},
	})

	return params
}

func (renderer *Renderer) createHandleActionCases() []ast.Stmt {
	caseClauses := make([]ast.Stmt, 0, len(renderer.States.Values))

	for _, action := range renderer.Actions.Values {
		caseClauses = append(
			caseClauses, createHandleActionCase(
				action, renderer.Codegen.Golang.Context))
	}

	caseClauses = append(caseClauses, &ast.CaseClause{
		Body: []ast.Stmt{
			&ast.ReturnStmt{
				Results: []ast.Expr{
					&ast.Ident{
						Name: "state",
					},
					&ast.Ident{
						Name: "runtime.ErrUnknownAction",
					},
				},
			},
		},
	})

	return caseClauses
}

func createHandleActionCase(
	action config.Action, context string,
) *ast.CaseClause {
	body := []ast.Stmt{}

	if action.DataType != "" {
		body = append(body, &ast.AssignStmt{
			Lhs: []ast.Expr{
				&ast.Ident{
					Name: "actionData",
				},
				&ast.Ident{
					Name: "ok",
				},
			},
			Tok: token.DEFINE,
			Rhs: []ast.Expr{
				&ast.TypeAssertExpr{
					X: &ast.Ident{
						Name: "data",
					},
					Type: &ast.Ident{
						Name: action.DataType,
					},
				},
			},
		}, &ast.IfStmt{
			Cond: &ast.UnaryExpr{
				Op: token.NOT,
				X: &ast.Ident{
					Name: "ok",
				},
			},
			Body: &ast.BlockStmt{
				List: []ast.Stmt{
					&ast.ReturnStmt{
						Results: []ast.Expr{
							&ast.Ident{
								Name: "state",
							},
							&ast.Ident{
								Name: "runtime.ErrInvalidActionDataType",
							},
						},
					},
				},
			},
		})
	}

	body = append(body, &ast.ReturnStmt{
		Results: []ast.Expr{
			&ast.CallExpr{
				Fun: &ast.Ident{
					Name: fmt.Sprintf("Handle%s", action.Name),
				},
				Args: createHandleActionArgs(action, context),
			},
		},
	})

	return &ast.CaseClause{
		List: []ast.Expr{
			&ast.Ident{
				Name: action.Symbol,
			},
		},
		Body: body,
	}
}

func createHandleActionArgs(
	action config.Action, context string,
) []ast.Expr {
	args := []ast.Expr{}

	if context != "" {
		args = append(args, &ast.Ident{
			Name: "ctx",
		})
	}

	args = append(args, &ast.Ident{
		Name: "handler",
	}, &ast.Ident{
		Name: "state",
	})

	if action.DataType != "" {
		args = append(args, &ast.Ident{
			Name: "actionData",
		})
	}

	return args
}

func (renderer *Renderer) createHandleActionMethod(
	action config.Action,
) *ast.FuncDecl {
	return &ast.FuncDecl{
		Doc: &ast.CommentGroup{
			List: []*ast.Comment{{
				Text: fmt.Sprintf("\n// Handles a \"%s\" action and returns the destination state or an error.\n", action.Name),
			}},
		},
		Name: &ast.Ident{
			Name: fmt.Sprintf("Handle%s", action.Name),
		},
		Type: &ast.FuncType{
			Params: &ast.FieldList{
				List: renderer.createHandleActionParams(action),
			},
			Results: &ast.FieldList{
				List: []*ast.Field{{
					Type: &ast.Ident{
						Name: renderer.States.Type,
					},
				}, {
					Type: &ast.Ident{
						Name: "error",
					},
				}},
			},
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.SwitchStmt{
					Tag: &ast.Ident{
						Name: "state",
					},
					Body: &ast.BlockStmt{
						List: renderer.createHandleCases(action),
					},
				},
				&ast.ReturnStmt{
					Results: []ast.Expr{
						&ast.Ident{
							Name: "state",
						},
						&ast.Ident{
							Name: "runtime.ErrNoTransition",
						},
					},
				},
			},
		},
	}
}

func (renderer *Renderer) createHandleActionParams(
	action config.Action,
) []*ast.Field {
	paramsList := []*ast.Field{}

	if renderer.Codegen.Golang.Context != "" {
		paramsList = append(paramsList, &ast.Field{
			Names: []*ast.Ident{{
				Name: "ctx",
			}},
			Type: &ast.Ident{
				Name: renderer.Codegen.Golang.Context,
			},
		})
	}

	paramsList = append(paramsList, &ast.Field{
		Names: []*ast.Ident{{
			Name: "handler",
		}},
		Type: &ast.Ident{
			Name: "Handler",
		},
	}, &ast.Field{
		Names: []*ast.Ident{{
			Name: "state",
		}},
		Type: &ast.Ident{
			Name: renderer.States.Type,
		},
	})

	if action.DataType != "" {
		paramsList = append(paramsList, &ast.Field{
			Names: []*ast.Ident{{
				Name: "data",
			}},
			Type: &ast.Ident{
				Name: action.DataType,
			},
		})
	}

	return paramsList
}

func (renderer *Renderer) createHandleCases(action config.Action) []ast.Stmt {
	handledStates := map[string]bool{}
	for _, state := range renderer.States.Values {
		handledStates[state.Name] = false
	}

	caseList, skippedStates := []ast.Stmt{}, []*config.State{}
	for index := range renderer.States.Values {
		state := &renderer.States.Values[index]

		var transitionAction *config.TransitionAction
		for index := range state.TransitionActions {
			if state.TransitionActions[index].Action == action.Name {
				transitionAction = &state.TransitionActions[index]
				break
			}
		}

		if transitionAction == nil {
			skippedStates = append(skippedStates, state)
			continue
		}

		caseList = append(caseList, &ast.CaseClause{
			List: []ast.Expr{
				&ast.Ident{
					Name: state.Symbol,
				},
			},
			Body: renderer.createHandleTransitions(
				state, action, transitionAction.Transitions),
		})
	}
	if len(skippedStates) > 0 {
		list := make([]ast.Expr, 0, len(skippedStates))
		for _, state := range skippedStates {
			list = append(list, &ast.Ident{
				Name: state.Symbol,
			})
		}
		caseList = append(caseList, &ast.CaseClause{
			List: list,
			Body: []ast.Stmt{
				&ast.BranchStmt{
					Tok: token.BREAK,
				},
			},
		})
	}
	caseList = append(caseList, &ast.CaseClause{
		Body: []ast.Stmt{
			&ast.ReturnStmt{
				Results: []ast.Expr{
					&ast.Ident{
						Name: "state",
					},
					&ast.Ident{
						Name: "runtime.ErrUnknownState",
					},
				},
			},
		},
	})

	return caseList
}

func (renderer *Renderer) createHandleTransitions(
	exitState *config.State, action config.Action,
	transitions []config.Transition,
) []ast.Stmt {
	var exitCall *ast.BlockStmt
	if exitState.Exit != "" {
		exitCall = renderer.createBoundaryHandler(
			exitState.Exit, renderer.Codegen.Golang.Context)
	}

	transitionList := []ast.Stmt{}
	for _, transition := range transitions {
		transitionCall := []ast.Stmt{}

		if exitCall != nil {
			transitionCall = append(transitionCall, exitCall)
		}

		if transition.Transition != "" {
			transitionCall = append(
				transitionCall, renderer.createTransitionHandler(
					action, transition.Transition))
		}

		destination := renderer.StatesMap[transition.Destination]
		if destination.Enter != "" {
			transitionCall = append(transitionCall, renderer.createBoundaryHandler(
				destination.Enter, renderer.Codegen.Golang.Context))
		}

		transitionCall = append(transitionCall, &ast.ReturnStmt{
			Results: []ast.Expr{
				&ast.Ident{
					Name: renderer.StatesMap[transition.Destination].Symbol,
				},
				&ast.Ident{
					Name: "nil",
				},
			},
		})

		if transition.Guard != "" {
			transitionList = append(transitionList, &ast.BlockStmt{
				List: []ast.Stmt{
					&ast.AssignStmt{
						Lhs: []ast.Expr{
							&ast.Ident{
								Name: "status",
							},
							&ast.Ident{
								Name: "err",
							},
						},
						Tok: token.DEFINE,
						Rhs: []ast.Expr{
							&ast.CallExpr{
								Fun: &ast.Ident{
									Name: fmt.Sprintf("handler.%s", transition.Guard),
								},
								Args: renderer.createActionHandlerArgs(action),
							},
						},
					}, &ast.IfStmt{
						Cond: &ast.BinaryExpr{
							X: &ast.Ident{
								Name: "err",
							},
							Op: token.NEQ,
							Y: &ast.Ident{
								Name: "nil",
							},
						},
						Body: &ast.BlockStmt{
							List: []ast.Stmt{
								&ast.ReturnStmt{
									Results: []ast.Expr{
										&ast.Ident{
											Name: "state",
										},
										&ast.Ident{
											Name: "err",
										},
									},
								},
							},
						},
					}, &ast.IfStmt{
						Cond: &ast.Ident{
							Name: "status",
						},
						Body: &ast.BlockStmt{
							List: transitionCall,
						},
					},
				},
			})
		} else {
			transitionList = append(transitionList, transitionCall...)
		}
	}

	return transitionList
}

func (renderer *Renderer) createBoundaryHandler(
	name string, context string,
) *ast.BlockStmt {
	return &ast.BlockStmt{
		List: []ast.Stmt{
			&ast.AssignStmt{
				Lhs: []ast.Expr{
					&ast.Ident{
						Name: "err",
					},
				},
				Tok: token.DEFINE,
				Rhs: []ast.Expr{
					&ast.CallExpr{
						Fun: &ast.Ident{
							Name: fmt.Sprintf("handler.%s", name),
						},
						Args: renderer.createBounHandlerArgs(),
					},
				},
			}, &ast.IfStmt{
				Cond: &ast.BinaryExpr{
					X: &ast.Ident{
						Name: "err",
					},
					Op: token.NEQ,
					Y: &ast.Ident{
						Name: "nil",
					},
				},
				Body: &ast.BlockStmt{
					List: []ast.Stmt{
						&ast.ReturnStmt{
							Results: []ast.Expr{
								&ast.Ident{
									Name: "state",
								},
								&ast.Ident{
									Name: "err",
								},
							},
						},
					},
				},
			},
		},
	}
}

func (renderer *Renderer) createTransitionHandler(
	action config.Action, name string,
) *ast.BlockStmt {
	return &ast.BlockStmt{
		List: []ast.Stmt{
			&ast.AssignStmt{
				Lhs: []ast.Expr{
					&ast.Ident{
						Name: "err",
					},
				},
				Tok: token.DEFINE,
				Rhs: []ast.Expr{
					&ast.CallExpr{
						Fun: &ast.Ident{
							Name: fmt.Sprintf("handler.%s", name),
						},
						Args: renderer.createActionHandlerArgs(action),
					},
				},
			}, &ast.IfStmt{
				Cond: &ast.BinaryExpr{
					X: &ast.Ident{
						Name: "err",
					},
					Op: token.NEQ,
					Y: &ast.Ident{
						Name: "nil",
					},
				},
				Body: &ast.BlockStmt{
					List: []ast.Stmt{
						&ast.ReturnStmt{
							Results: []ast.Expr{
								&ast.Ident{
									Name: "state",
								},
								&ast.Ident{
									Name: "err",
								},
							},
						},
					},
				},
			},
		},
	}
}

func (renderer *Renderer) createBounHandlerArgs() []ast.Expr {
	args := []ast.Expr{}

	if renderer.Codegen.Golang.Context != "" {
		args = append(args, &ast.Ident{
			Name: "ctx",
		})
	}

	return args
}

func (renderer *Renderer) createActionHandlerArgs(
	action config.Action,
) []ast.Expr {
	args := []ast.Expr{}

	if renderer.Codegen.Golang.Context != "" {
		args = append(args, &ast.Ident{
			Name: "ctx",
		})
	}

	if action.DataType != "" {
		args = append(args, &ast.Ident{
			Name: "data",
		})
	}

	return args
}
