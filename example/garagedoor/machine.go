// Autogenerated. Do not modify.
//
// This file can be regenerated by running
// go run github.com/arnavdugar/hsm/codegen -i=machine.yaml -o=machine.go

package garagedoor

import "github.com/arnavdugar/hsm/runtime"

type ActionType int

const (
	ActionButton ActionType = 1
	ActionOpened ActionType = 2
	ActionClosed ActionType = 3
	ActionSensor ActionType = 4
)

type StateType int

const (
	StateStoppedClosing StateType = 1
	StateOpening        StateType = 2
	StateStoppedOpening StateType = 3
	StateClosing        StateType = 4
)

type Handler interface {
	HandleButtonWhenStoppedClosing() error
	HandleButtonWhenOpening() error
	HandleButtonWhenStoppedOpening() error
	HandleButtonWhenClosing() error
	HandleOpened() error
	HandleClosed() error
	HandleSensor() error
}

// Handles an action and returns the destination state or an error.
func Handle(handler Handler, state StateType, action ActionType, data interface{}) (StateType, error) {
	switch action {
	case ActionButton:
		return HandleButton(handler, state)
	case ActionOpened:
		return HandleOpened(handler, state)
	case ActionClosed:
		return HandleClosed(handler, state)
	case ActionSensor:
		return HandleSensor(handler, state)
	default:
		return state, runtime.ErrUnknownAction
	}
}

// Handles a "Button" action and returns the destination state or an error.
func HandleButton(handler Handler, state StateType) (StateType, error) {
	switch state {
	case StateStoppedClosing:
		{
			err := handler.HandleButtonWhenStoppedClosing()
			if err != nil {
				return state, err
			}
		}
		return StateOpening, nil
	case StateOpening:
		{
			err := handler.HandleButtonWhenOpening()
			if err != nil {
				return state, err
			}
		}
		return StateStoppedOpening, nil
	case StateStoppedOpening:
		{
			err := handler.HandleButtonWhenStoppedOpening()
			if err != nil {
				return state, err
			}
		}
		return StateClosing, nil
	case StateClosing:
		{
			err := handler.HandleButtonWhenClosing()
			if err != nil {
				return state, err
			}
		}
		return StateStoppedClosing, nil
	default:
		return state, runtime.ErrUnknownState
	}
	return state, runtime.ErrNoTransition
}

// Handles a "Opened" action and returns the destination state or an error.
func HandleOpened(handler Handler, state StateType) (StateType, error) {
	switch state {
	case StateOpening:
		{
			err := handler.HandleOpened()
			if err != nil {
				return state, err
			}
		}
		return StateStoppedOpening, nil
	case StateStoppedClosing, StateStoppedOpening, StateClosing:
		break
	default:
		return state, runtime.ErrUnknownState
	}
	return state, runtime.ErrNoTransition
}

// Handles a "Closed" action and returns the destination state or an error.
func HandleClosed(handler Handler, state StateType) (StateType, error) {
	switch state {
	case StateClosing:
		{
			err := handler.HandleClosed()
			if err != nil {
				return state, err
			}
		}
		return StateStoppedClosing, nil
	case StateStoppedClosing, StateOpening, StateStoppedOpening:
		break
	default:
		return state, runtime.ErrUnknownState
	}
	return state, runtime.ErrNoTransition
}

// Handles a "Sensor" action and returns the destination state or an error.
func HandleSensor(handler Handler, state StateType) (StateType, error) {
	switch state {
	case StateClosing:
		{
			err := handler.HandleSensor()
			if err != nil {
				return state, err
			}
		}
		return StateOpening, nil
	case StateStoppedClosing, StateOpening, StateStoppedOpening:
		break
	default:
		return state, runtime.ErrUnknownState
	}
	return state, runtime.ErrNoTransition
}
