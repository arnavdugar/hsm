// Autogenerated. Do not modify.
//
// This file can be regenerated by running
// go run github.com/arnavdugar/hsm/codegen -i=machine.yaml -o=machine.go

package queue

import "github.com/arnavdugar/hsm/runtime"

type ActionType int

const (
	ActionPushElement    ActionType = 1
	ActionConsumeElement ActionType = 2
	ActionClose          ActionType = 3
)

type StateType int

const (
	StateQueueEmpty       StateType = 1
	StateQueueHasElements StateType = 2
	StateClosed           StateType = 3
)

type Handler interface {
	HandlePushElement(data QueueElement) error
	HasSingleElement() (bool, error)
	HandleConsumeElement() error
	HandleClose() error
}

// Handles an action and returns the destination state or an error.
func Handle(handler Handler, state StateType, action ActionType, data interface{}) (StateType, error) {
	switch action {
	case ActionPushElement:
		actionData, ok := data.(QueueElement)
		if !ok {
			return state, runtime.ErrInvalidActionDataType
		}
		return HandlePushElement(handler, state, actionData)
	case ActionConsumeElement:
		return HandleConsumeElement(handler, state)
	case ActionClose:
		return HandleClose(handler, state)
	default:
		return state, runtime.ErrUnknownAction
	}
}

// Handles a "PushElement" action and returns the destination state or an error.
func HandlePushElement(handler Handler, state StateType, data QueueElement) (StateType, error) {
	switch state {
	case StateQueueEmpty:
		{
			err := handler.HandlePushElement(data)
			if err != nil {
				return state, err
			}
		}
		return StateQueueHasElements, nil
	case StateQueueHasElements:
		{
			err := handler.HandlePushElement(data)
			if err != nil {
				return state, err
			}
		}
		return StateQueueHasElements, nil
	case StateClosed:
		break
	default:
		return state, runtime.ErrUnknownState
	}
	return state, runtime.ErrNoTransition
}

// Handles a "ConsumeElement" action and returns the destination state or an error.
func HandleConsumeElement(handler Handler, state StateType) (StateType, error) {
	switch state {
	case StateQueueHasElements:
		{
			status, err := handler.HasSingleElement()
			if err != nil {
				return state, err
			}
			if status {
				{
					err := handler.HandleConsumeElement()
					if err != nil {
						return state, err
					}
				}
				return StateQueueEmpty, nil
			}
		}
		{
			err := handler.HandleConsumeElement()
			if err != nil {
				return state, err
			}
		}
		return StateQueueHasElements, nil
	case StateQueueEmpty, StateClosed:
		break
	default:
		return state, runtime.ErrUnknownState
	}
	return state, runtime.ErrNoTransition
}

// Handles a "Close" action and returns the destination state or an error.
func HandleClose(handler Handler, state StateType) (StateType, error) {
	switch state {
	case StateQueueEmpty:
		{
			err := handler.HandleClose()
			if err != nil {
				return state, err
			}
		}
		return StateClosed, nil
	case StateQueueHasElements, StateClosed:
		break
	default:
		return state, runtime.ErrUnknownState
	}
	return state, runtime.ErrNoTransition
}
