// Autogenerated. Do not modify.
//
// This file can be regenerated by running
// go run github.com/arnavdugar/hsm/codegen -i=machine.yaml -o=machine.go

package boundary

import (
	"github.com/arnavdugar/hsm/runtime"
	"context"
)

type ActionType int

const ActionNext ActionType = 1

type StateType int

const (
	StateA StateType = 1
	StateB StateType = 2
	StateC StateType = 3
)

type Handler interface {
	OnEnterA(ctx context.Context) error
	OnExitA(ctx context.Context) error
	OnEnterB(ctx context.Context) error
	OnExitB(ctx context.Context) error
	OnEnterC(ctx context.Context) error
	OnExitC(ctx context.Context) error
}

// Handles an action and returns the destination state or an error.
func Handle(ctx context.Context, handler Handler, state StateType, action ActionType, data interface{}) (StateType, error) {
	switch action {
	case ActionNext:
		return HandleNext(ctx, handler, state)
	default:
		return state, runtime.ErrUnknownAction
	}
}

// Handles a "Next" action and returns the destination state or an error.
func HandleNext(ctx context.Context, handler Handler, state StateType) (StateType, error) {
	switch state {
	case StateA:
		{
			err := handler.OnExitA(ctx)
			if err != nil {
				return state, err
			}
		}
		{
			err := handler.OnEnterB(ctx)
			if err != nil {
				return state, err
			}
		}
		return StateB, nil
	case StateB:
		{
			err := handler.OnExitB(ctx)
			if err != nil {
				return state, err
			}
		}
		{
			err := handler.OnEnterC(ctx)
			if err != nil {
				return state, err
			}
		}
		return StateC, nil
	case StateC:
		{
			err := handler.OnExitC(ctx)
			if err != nil {
				return state, err
			}
		}
		{
			err := handler.OnEnterA(ctx)
			if err != nil {
				return state, err
			}
		}
		return StateA, nil
	default:
		return state, runtime.ErrUnknownState
	}
	return state, runtime.ErrNoTransition
}
